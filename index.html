<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <title>Strategic Kingdoms 2025</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background: #0a0a0a;
      color: #e0e0e0;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }

    #game-container {
      position: relative;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
    }

    canvas {
      display: block;
      image-rendering: pixelated;
    }

    #ui-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    #top-panel {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 50px;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      padding: 0 20px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(5px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 100;
    }

    #resources {
      display: flex;
      gap: 20px;
      font-size: 16px;
    }

    .resource {
      display: flex;
      align-items: center;
      gap: 8px;
      background: rgba(40, 40, 40, 0.7);
      padding: 5px 12px;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: transform 0.2s, background 0.2s;
    }

    .resource:hover {
      transform: scale(1.05);
      background: rgba(60, 60, 60, 0.7);
    }

    .resource-icon {
      font-size: 20px;
    }

    #side-panel {
      position: absolute;
      top: 60px;
      right: 10px;
      width: 260px;
      background: rgba(0, 0, 0, 0.75);
      backdrop-filter: blur(5px);
      border-radius: 10px;
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
      pointer-events: auto;
      border: 1px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
      z-index: 90;
    }

    .panel-section {
      padding: 15px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .panel-title {
      margin: 0 0 10px 0;
      font-size: 16px;
      color: #ccc;
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .panel-title::after {
      content: '';
      flex-grow: 1;
      height: 1px;
      background: rgba(255, 255, 255, 0.2);
    }

    .button-grid {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 8px;
    }

    button {
      background: linear-gradient(to bottom, #404040, #303030);
      color: #e0e0e0;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 10px 5px;
      font-size: 13px;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      transition: all 0.2s;
      outline: none;
    }

    button:hover:not(:disabled) {
      background: linear-gradient(to bottom, #505050, #404040);
      border-color: rgba(255, 255, 255, 0.3);
      transform: translateY(-2px);
    }

    button:active:not(:disabled) {
      transform: translateY(1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-icon {
      font-size: 18px;
    }

    .resource-cost {
      display: flex;
      font-size: 11px;
      gap: 5px;
      color: #aaa;
    }

    #minimap {
      position: absolute;
      bottom: 20px;
      right: 20px;
      width: 230px;
      height: 180px;
      background: rgba(0, 0, 0, 0.7);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 10px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
      pointer-events: auto;
      transition: transform 0.3s, box-shadow 0.3s;
      overflow: hidden;
      z-index: 80;
    }

    #minimap:hover {
      transform: scale(1.1);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.7);
    }

    #minimap-canvas {
      width: 100%;
      height: 100%;
      border-radius: 10px;
    }

    #status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 40px;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      padding: 0 20px;
      font-size: 14px;
      backdrop-filter: blur(5px);
      border-top: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 100;
    }

    #tooltip {
      position: absolute;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 5px;
      padding: 10px;
      pointer-events: none;
      max-width: 250px;
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.2s;
      z-index: 200;
    }

    .tooltip-title {
      font-weight: bold;
      margin-bottom: 5px;
      color: #fff;
    }

    .tooltip-description {
      color: #aaa;
    }

    #loading-screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 1s;
    }

    #loading-logo {
      font-size: 40px;
      font-weight: bold;
      margin-bottom: 20px;
      text-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
    }

    #loading-progress {
      width: 300px;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    #loading-bar {
      height: 100%;
      width: 0%;
      background: linear-gradient(to right, #4CAF50, #8BC34A);
      transition: width 0.3s;
    }

    #loading-text {
      margin-top: 10px;
      font-size: 14px;
      color: #aaa;
    }

    .unit-selection {
      position: absolute;
      border: 2px solid rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      pointer-events: none;
    }

    .health-bar {
      position: absolute;
      height: 4px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 2px;
      overflow: hidden;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(to right, #f00, #f70);
    }

    .building-health-bar {
      position: absolute;
      height: 5px;
      background: rgba(0, 0, 0, 0.5);
      overflow: hidden;
    }

    .resource-indicator {
      position: absolute;
      font-size: 12px;
      color: white;
      pointer-events: none;
      text-shadow: 0px 0px 2px black, 0px 0px 4px black;
      animation: float-up 1.5s forwards ease-out;
      opacity: 0;
    }

    @keyframes float-up {
      0% {
        transform: translateY(0);
        opacity: 0;
      }
      20% {
        opacity: 1;
      }
      100% {
        transform: translateY(-25px);
        opacity: 0;
      }
    }

    .selection-box {
      position: absolute;
      border: 1px solid rgba(100, 200, 255, 0.7);
      background: rgba(100, 200, 255, 0.1);
      pointer-events: none;
    }

    .building-ghost {
      position: absolute;
      pointer-events: none;
    }

    /* Animations */
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    .pulse {
      animation: pulse 0.5s;
    }
  </style>
</head>
<body>
<div id="game-container">
  <canvas id="game-canvas"></canvas>

  <div id="ui-overlay">
    <div id="top-panel">
      <div id="resources">
        <div class="resource">
          <span class="resource-icon">üåæ</span>
          <span id="food">100</span>
        </div>
        <div class="resource">
          <span class="resource-icon">ü™µ</span>
          <span id="wood">100</span>
        </div>
        <div class="resource">
          <span class="resource-icon">‚õèÔ∏è</span>
          <span id="stone">50</span>
        </div>
        <div class="resource">
          <span class="resource-icon">üë•</span>
          <span id="population">0/10</span>
        </div>
      </div>
    </div>

    <div id="side-panel">
      <div class="panel-section">
        <h3 class="panel-title">Unit√©s</h3>
        <div class="button-grid">
          <button id="villager-btn" onclick="spawnVillager()">
            <span class="btn-icon">üë®‚Äçüåæ</span>
            Villageois
            <div class="resource-cost">
              <span>üåæ 5</span>
            </div>
          </button>
          <button id="soldier-btn" onclick="spawnSoldier()">
            <span class="btn-icon">‚öîÔ∏è</span>
            Soldat
            <div class="resource-cost">
              <span>üåæ 10</span>
              <span>ü™µ 5</span>
            </div>
          </button>
          <button id="archer-btn" onclick="spawnArcher()">
            <span class="btn-icon">üèπ</span>
            Archer
            <div class="resource-cost">
              <span>üåæ 10</span>
              <span>ü™µ 10</span>
            </div>
          </button>
          <button id="knight-btn" onclick="spawnKnight()">
            <span class="btn-icon">üõ°Ô∏è</span>
            Chevalier
            <div class="resource-cost">
              <span>üåæ 20</span>
              <span>‚õèÔ∏è 15</span>
            </div>
          </button>
        </div>
      </div>

      <div class="panel-section">
        <h3 class="panel-title">B√¢timents</h3>
        <div class="button-grid">
          <button id="house-btn" onclick="buildStructure('house')">
            <span class="btn-icon">üè†</span>
            Maison
            <div class="resource-cost">
              <span>ü™µ 10</span>
            </div>
          </button>
          <button id="farm-btn" onclick="buildStructure('farm')">
            <span class="btn-icon">üåæ</span>
            Ferme
            <div class="resource-cost">
              <span>ü™µ 5</span>
              <span>‚õèÔ∏è 3</span>
            </div>
          </button>
          <button id="lumbermill-btn" onclick="buildStructure('lumbermill')">
            <span class="btn-icon">ü™ì</span>
            Scierie
            <div class="resource-cost">
              <span>ü™µ 8</span>
              <span>‚õèÔ∏è 5</span>
            </div>
          </button>
          <button id="quarry-btn" onclick="buildStructure('quarry')">
            <span class="btn-icon">üî®</span>
            Carri√®re
            <div class="resource-cost">
              <span>ü™µ 10</span>
              <span>‚õèÔ∏è 5</span>
            </div>
          </button>
          <button id="barracks-btn" onclick="buildStructure('barracks')">
            <span class="btn-icon">‚öîÔ∏è</span>
            Caserne
            <div class="resource-cost">
              <span>ü™µ 15</span>
              <span>‚õèÔ∏è 10</span>
            </div>
          </button>
          <button id="archery-btn" onclick="buildStructure('archery')">
            <span class="btn-icon">üèπ</span>
            Stand de tir
            <div class="resource-cost">
              <span>ü™µ 15</span>
              <span>‚õèÔ∏è 8</span>
            </div>
          </button>
        </div>
      </div>
    </div>

    <div id="minimap">
      <canvas id="minimap-canvas"></canvas>
    </div>

    <div id="status-bar">
      Bienvenue dans Strategic Kingdoms 2025! Commencez par construire des b√¢timents et cr√©er des unit√©s.
    </div>

    <div id="tooltip">
      <div class="tooltip-title">Villageois</div>
      <div class="tooltip-description">Une unit√© de base qui peut r√©colter des ressources et construire des b√¢timents.</div>
    </div>
  </div>

  <div id="loading-screen">
    <div id="loading-logo">STRATEGIC KINGDOMS 2025</div>
    <div id="loading-progress">
      <div id="loading-bar"></div>
    </div>
    <div id="loading-text">Chargement des ressources...</div>
  </div>
</div>

<script>
// Configuration du jeu
const config = {
  tileSize: 64,
  mapWidth: 50,
  mapHeight: 40,
  updateInterval: 16, // 60 FPS
  resourceGatherRate: 1,
  resourceGatherInterval: 500,
  enemySpawnInterval: 30000,
  enemyDamage: 2,
  soldierDamage: 3,
  archerDamage: 2,
  archerRange: 5,
  knightDamage: 5,
  villagerDamage: 1,
  maxPopulation: 10,
  fogOfWarEnabled: true,
  soundEnabled: true,
  musicEnabled: true
};

// Assets √† charger
const assets = {
  images: {
    // Terrain
    grassTile: 'https://i.imgur.com/B1nV2HT.png',
    waterTile: 'https://i.imgur.com/kWw36HA.png',
    sandTile: 'https://i.imgur.com/Bqlv6c5.png',
    stoneTile: 'https://i.imgur.com/0iLH8tN.png',
    dirtTile: 'https://i.imgur.com/MKjEg5m.png',
    mountainTile: 'https://i.imgur.com/ZK0BcLs.png',

    // Ressources
    tree: 'https://i.imgur.com/pfC0lO8.png',
    berry: 'https://i.imgur.com/JTLqR5N.png',
    stone: 'https://i.imgur.com/8qLjUww.png',

    // Unit√©s
    villager: 'https://i.imgur.com/YBo9e26.png',
    soldier: 'https://i.imgur.com/2wTXcSV.png',
    archer: 'https://i.imgur.com/R7PiJRn.png',
    knight: 'https://i.imgur.com/Lrd2V8S.png',
    enemy: 'https://i.imgur.com/HQExWME.png',

    // B√¢timents
    house: 'https://i.imgur.com/v9uRHVF.png',
    farm: 'https://i.imgur.com/4EmNlNH.png',
    lumbermill: 'https://i.imgur.com/7M5KrJM.png',
    quarry: 'https://i.imgur.com/dIlAT2o.png',
    barracks: 'https://i.imgur.com/WP68q97.png',
    archery: 'https://i.imgur.com/ZK0BcLs.png',
    towncenter: 'https://i.imgur.com/JZrxkBG.png',

    // Effets
    selectionCircle: 'https://i.imgur.com/iLvjmZ7.png',
    selectionSquare: 'https://i.imgur.com/JJy7yL3.png',
    constructionEffect: 'https://i.imgur.com/bpMJRGZ.png',
    attackEffect: 'https://i.imgur.com/C9NeZdw.png',
    treeDestructionEffect: 'https://i.imgur.com/VRCN5bX.png',
    fogOfWar: 'https://i.imgur.com/0WUE4UB.png'
  },
  sounds: {
    villagerCreate: 'https://assets.mixkit.co/sfx/download/mixkit-quick-jump-arcade-game-239.wav',
    villagerAcknowledge: 'https://assets.mixkit.co/sfx/download/mixkit-positive-interface-beep-221.wav',
    villagerHarvest: 'https://assets.mixkit.co/sfx/download/mixkit-metal-hit-woosh-1485.wav',
    soldierCreate: 'https://assets.mixkit.co/sfx/download/mixkit-sword-blade-slide-2788.wav',
    soldierAcknowledge: 'https://assets.mixkit.co/sfx/download/mixkit-extra-bonus-in-a-video-game-2045.wav',
    soldierAttack: 'https://assets.mixkit.co/sfx/download/mixkit-sword-cut-swoosh-1476.wav',
    buildingPlace: 'https://assets.mixkit.co/sfx/download/mixkit-arcade-game-jump-coin-216.wav',
    buildingDestroy: 'https://assets.mixkit.co/sfx/download/mixkit-falling-game-over-1942.wav',
    treeChop: 'https://assets.mixkit.co/sfx/download/mixkit-hitting-wood-with-metal-2178.wav',
    rockMine: 'https://assets.mixkit.co/sfx/download/mixkit-hitting-a-rock-with-a-pick-2879.wav',
    berryPick: 'https://assets.mixkit.co/sfx/download/mixkit-plastic-bubble-click-1343.wav',
    enemySpawn: 'https://assets.mixkit.co/sfx/download/mixkit-sword-slash-swoosh-1476.wav',
    enemyDeath: 'https://assets.mixkit.co/sfx/download/mixkit-dramatic-metal-explosion-impact-1687.wav',
    buttonClick: 'https://assets.mixkit.co/sfx/download/mixkit-select-click-1109.wav',
    errorSound: 'https://assets.mixkit.co/sfx/download/mixkit-wrong-answer-fail-notification-946.wav'
  },
  music: {
    gameTheme: 'https://assets.mixkit.co/music/download/mixkit-games-worldbeat-668.mp3'
  }
};

// √âtat du jeu
const gameState = {
  map: [],
  resources: { food: 100, wood: 100, stone: 50, population: 0, maxPopulation: 10 },
  trees: [],
  stones: [],
  berries: [],
  units: {
    villagers: [],
    soldiers: [],
    archers: [],
    knights: []
  },
  enemies: [],
  buildings: [],
  selected: [],
  buildMode: null,
  camera: { x: 0, y: 0, targetX: 0, targetY: 0, speed: 0.1 },
  selectionBox: null,
  gameTime: 0,
  effectsQueue: [],
  revealedMap: [], // Pour le brouillard de guerre
  lastFrameTime: 0,
  deltaTime: 0,
  tooltip: { target: null, x: 0, y: 0 },
  soundsLoaded: 0,
  soundsToLoad: 0,
  imagesLoaded: 0,
  imagesToLoad: 0,
  loadingComplete: false,
  spritesheets: {}
};

// Cache des ressources
const resourceCache = {
  images: {},
  sounds: {},
  music: {}
};

// Initialisation du canvas et du contexte
const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const minimap = document.getElementById('minimap-canvas');
const minimapCtx = minimap.getContext('2d');
const tooltip = document.getElementById('tooltip');
const statusBar = document.getElementById('status-bar');
const loadingBar = document.getElementById('loading-bar');
const loadingText = document.getElementById('loading-text');
const loadingScreen = document.getElementById('loading-screen');

// Adapter la taille du canvas √† la fen√™tre
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  minimap.width = 230;
  minimap.height = 180;

  // Redessiner apr√®s redimensionnement
  if (gameState.loadingComplete) {
    draw();
  }
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Charger les ressources
function loadResources() {
  // Compter le nombre total d'assets √† charger
  gameState.imagesToLoad = Object.keys(assets.images).length;
  gameState.soundsToLoad = Object.keys(assets.sounds).length + Object.keys(assets.music).length;

  // Charger les images
  for (const key in assets.images) {
    const img = new Image();
    img.src = assets.images[key];
    img.onload = () => {
      resourceCache.images[key] = img;
      gameState.imagesLoaded++;
      updateLoadingProgress();
    };
    img.onerror = () => {
      console.error(`Failed to load image: ${key}`);
      gameState.imagesLoaded++;
      updateLoadingProgress();
    };
  }

  // Charger les sons
  for (const key in assets.sounds) {
    const sound = new Audio();
    sound.src = assets.sounds[key];
    sound.oncanplaythrough = () => {
      resourceCache.sounds[key] = sound;
      gameState.soundsLoaded++;
      updateLoadingProgress();
    };
    sound.onerror = () => {
      console.error(`Failed to load sound: ${key}`);
      gameState.soundsLoaded++;
      updateLoadingProgress();
    };
  }

  // Charger la musique
  for (const key in assets.music) {
    const music = new Audio();
    music.src = assets.music[key];
    music.loop = true;
    music.oncanplaythrough = () => {
      resourceCache.music[key] = music;
      gameState.soundsLoaded++;
      updateLoadingProgress();
    };
    music.onerror = () => {
      console.error(`Failed to load music: ${key}`);
      gameState.soundsLoaded++;
      updateLoadingProgress();
    };
  }
}

// Mettre √† jour la barre de progression
function updateLoadingProgress() {
  const totalAssets = gameState.imagesToLoad + gameState.soundsToLoad;
  const loadedAssets = gameState.imagesLoaded + gameState.soundsLoaded;
  const progress = Math.floor((loadedAssets / totalAssets) * 100);

  loadingBar.style.width = `${progress}%`;
  loadingText.textContent = `Chargement des ressources... ${progress}%`;

  if (loadedAssets >= totalAssets) {
    // Tout est charg√©, on peut initialiser le jeu
    setTimeout(() => {
      gameState.loadingComplete = true;
      loadingScreen.style.opacity = '0';
      setTimeout(() => {
        loadingScreen.style.display = 'none';
        initGame();
      }, 1000);
    }, 500);
  }
}

// Jouer un son avec contr√¥le du volume
function playSound(key, volume = 1.0) {
  if (!config.soundEnabled || !resourceCache.sounds[key]) return;

  // Cloner le son pour pouvoir jouer plusieurs instances en m√™me temps
  const sound = resourceCache.sounds[key].cloneNode();
  sound.volume = volume;
  sound.play();
}

// Jouer la musique de fond
function playMusic(key, volume = 0.3) {
  if (!config.musicEnabled || !resourceCache.music[key]) return;

  const music = resourceCache.music[key];
  music.volume = volume;
  music.currentTime = 0;
  music.play();
}

// Arr√™ter la musique de fond
function stopMusic(key) {
  if (!resourceCache.music[key]) return;

  const music = resourceCache.music[key];
  music.pause();
  music.currentTime = 0;
}

// Initialisation de la carte
function initMap() {
  console.log("Initialisation de la carte al√©atoire...");

  // R√©initialiser les tableaux
  gameState.map = [];
  gameState.trees = [];
  gameState.stones = [];
  gameState.berries = [];
  gameState.revealedMap = [];

  // G√©n√©rer la carte de mani√®re al√©atoire
  const mapData = generateRandomMap(config.mapWidth, config.mapHeight);

  // Convertir mapData en map du jeu
  for (let y = 0; y < mapData.length; y++) {
    const row = [];
    const revealedRow = [];

    for (let x = 0; x < mapData[y].length; x++) {
      let tile;

      switch(mapData[y][x]) {
        case 1: tile = 'water'; break;
        case 2: tile = 'sand'; break;
        case 3: tile = 'stone'; break;
        case 4: tile = 'mountain'; break;
        default: tile = 'grass';
      }

      row.push(tile);

      // Tout est visible au d√©but
      revealedRow.push(2);
    }

    gameState.map.push(row);
    gameState.revealedMap.push(revealedRow);
  }

  // Configurer les dimensions de la carte
  config.mapWidth = mapData[0].length;
  config.mapHeight = mapData.length;

  // Ajouter les ressources
  addResourcesToMap();

  // Ajouter des villageois de d√©part
  spawnUnit(Math.floor(config.mapWidth / 2), Math.floor(config.mapHeight / 2), 'villager');
  spawnUnit(Math.floor(config.mapWidth / 2) + 1, Math.floor(config.mapHeight / 2), 'villager');

  console.log("Carte cr√©√©e al√©atoirement:", config.mapWidth, "x", config.mapHeight);
}

// G√©n√©rer une carte al√©atoire
function generateRandomMap(width, height) {
  const map = [];

  for (let y = 0; y < height; y++) {
    const row = [];
    for (let x = 0; x < width; x++) {
      const rand = Math.random();
      if (rand < 0.05) {
        row.push(4); // Montagne
      } else if (rand < 0.1) {
        row.push(3); // Pierre
      } else if (rand < 0.15) {
        row.push(2); // Sable
      } else if (rand < 0.2) {
        row.push(1); // Eau
      } else {
        row.push(0); // Herbe
      }
    }
    map.push(row);
  }

  return map;
}

// Ajouter des ressources √† la carte
function addResourcesToMap() {
  const numTrees = 50;
  const numStones = 30;
  const numBerries = 20;

  function placeResource(type, num) {
    const positions = [];
    for (let i = 0; i < num; i++) {
      let x, y;
      do {
        x = Math.floor(Math.random() * config.mapWidth);
        y = Math.floor(Math.random() * config.mapHeight);
      } while (gameState.map[y][x] !== 0 || positions.some(pos => pos.x === x && pos.y === y));
      positions.push({ x, y });
    }
    gameState[type] = positions;
  }

  placeResource('trees', numTrees);
  placeResource('stones', numStones);
  placeResource('berries', numBerries);
}

// Spawn des unit√©s
function spawnUnit(x, y, type) {
  // V√©rifier les limites de population
  if (gameState.resources.population >= gameState.resources.maxPopulation) {
    updateStatus("Population maximale atteinte. Construisez plus de maisons.");
    playSound('errorSound', 0.5);
    return null;
  }

  let stats = {
    hp: 10,
    maxHp: 10,
    attack: 1,
    defense: 0,
    speed: 0.07,
    range: 1,
    productionTime: 5000
  };

  switch (type) {
    case 'soldier':
      stats = { ...stats, hp: 20, maxHp: 20, attack: 3, defense: 1, speed: 0.05 };
      break;
    case 'archer':
      stats = { ...stats, hp: 15, maxHp: 15, attack: 2, defense: 0, speed: 0.06, range: 5 };
      break;
    case 'knight':
      stats = { ...stats, hp: 30, maxHp: 30, attack: 5, defense: 3, speed: 0.04 };
      break;
  }

  const unit = {
    x, y,
    targetX: x,
    targetY: y,
    type,
    selected: false,
    hp: stats.hp,
    maxHp: stats.maxHp,
    attack: stats.attack,
    defense: stats.defense,
    task: null,
    taskTarget: null,
    speed: stats.speed,
    range: stats.range,
    direction: 'down', // Pour l'animation
    isMoving: false,
    attackCooldown: 0,
    animationFrame: 0,
    animationTime: 0
  };

  gameState.resources.population++;
  updateUI();

  if (type === 'villager') {
    gameState.units.villagers.push(unit);
    playSound('villagerCreate');
  } else if (type === 'soldier') {
    gameState.units.soldiers.push(unit);
    playSound('soldierCreate');
  } else if (type === 'archer') {
    gameState.units.archers.push(unit);
    playSound('soldierCreate', 0.7);
  } else if (type === 'knight') {
    gameState.units.knights.push(unit);
    playSound('soldierCreate', 0.9);
  }

  // Ajouter un effet de cr√©ation
  addEffect('spawn', x, y, 500);

  return unit;
}

function spawnVillager() {
  if (gameState.resources.food >= 5) {
    // Trouver un b√¢timent de type mairie pour faire appara√Ætre des villageois
    const townCenter = gameState.buildings.find(b => b.type === 'towncenter');
    let spawnX = Math.floor(config.mapWidth / 2);
    let spawnY = Math.floor(config.mapHeight / 2);

    if (townCenter) {
      spawnX = townCenter.x + townCenter.width / 2;
      spawnY = townCenter.y + townCenter.height / 2;
    }

    const unit = spawnUnit(spawnX, spawnY, 'villager');
    if (unit) {
      gameState.resources.food -= 5;
      updateUI();
      updateStatus("Villageois cr√©√©");
    }
  } else {
    updateStatus("Pas assez de nourriture pour cr√©er un villageois");
    playSound('errorSound', 0.5);
  }
}

function spawnSoldier() {
  if (gameState.resources.food >= 10 && gameState.resources.wood >= 5) {
    // V√©rifier si une caserne existe
    const barracks = gameState.buildings.find(b => b.type === 'barracks');

    if (barracks) {
      const unit = spawnUnit(barracks.x + barracks.width / 2, barracks.y + barracks.height / 2, 'soldier');
      if (unit) {
        gameState.resources.food -= 10;
        gameState.resources.wood -= 5;
        updateUI();
        updateStatus("Soldat cr√©√©");
      }
    } else {
      updateStatus("Vous avez besoin d'une caserne pour cr√©er des soldats");
      playSound('errorSound', 0.5);
    }
  } else {
    updateStatus("Ressources insuffisantes pour cr√©er un soldat");
    playSound('errorSound', 0.5);
  }
}

function spawnArcher() {
  if (gameState.resources.food >= 10 && gameState.resources.wood >= 10) {
    // V√©rifier si un stand de tir existe
    const archery = gameState.buildings.find(b => b.type === 'archery');

    if (archery) {
      const unit = spawnUnit(archery.x + archery.width / 2, archery.y + archery.height / 2, 'archer');
      if (unit) {
        gameState.resources.food -= 10;
        gameState.resources.wood -= 10;
        updateUI();
        updateStatus("Archer cr√©√©");
      }
    } else {
      updateStatus("Vous avez besoin d'un stand de tir pour cr√©er des archers");
      playSound('errorSound', 0.5);
    }
  } else {
    updateStatus("Ressources insuffisantes pour cr√©er un archer");
    playSound('errorSound', 0.5);
  }
}

function spawnKnight() {
  if (gameState.resources.food >= 20 && gameState.resources.stone >= 15) {
    // V√©rifier si une caserne existe
    const barracks = gameState.buildings.find(b => b.type === 'barracks');

    if (barracks) {
      const unit = spawnUnit(barracks.x + barracks.width / 2, barracks.y + barracks.height / 2, 'knight');
      if (unit) {
        gameState.resources.food -= 20;
        gameState.resources.stone -= 15;
        updateUI();
        updateStatus("Chevalier cr√©√©");
      }
    } else {
      updateStatus("Vous avez besoin d'une caserne pour cr√©er des chevaliers");
      playSound('errorSound', 0.5);
    }
  } else {
    updateStatus("Ressources insuffisantes pour cr√©er un chevalier");
    playSound('errorSound', 0.5);
  }
}

function spawnEnemy() {
  // Faire appara√Ætre des ennemis sur les bords de la carte
  const side = Math.floor(Math.random() * 4);
  let x, y;

  switch(side) {
    case 0: // Haut
      x = Math.floor(Math.random() * config.mapWidth);
      y = 0;
      break;
    case 1: // Droite
      x = config.mapWidth - 1;
      y = Math.floor(Math.random() * config.mapHeight);
      break;
    case 2: // Bas
      x = Math.floor(Math.random() * config.mapWidth);
      y = config.mapHeight - 1;
      break;
    case 3: // Gauche
      x = 0;
      y = Math.floor(Math.random() * config.mapHeight);
      break;
  }

  // Ne pas appara√Ætre sur l'eau
  if (gameState.map[y][x] === 'water') {
    // Essayer de nouveau
    setTimeout(spawnEnemy, 1000);
    return;
  }

  // Type d'ennemi al√©atoire
  const enemyTypes = ['basic', 'fast', 'strong'];
  const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];

  let stats = {
    hp: 15,
    maxHp: 15,
    attack: 2,
    defense: 0,
    speed: 0.03,
    range: 1
  };

  switch (enemyType) {
    case 'fast':
      stats = { ...stats, hp: 10, maxHp: 10, attack: 1, speed: 0.05 };
      break;
    case 'strong':
      stats = { ...stats, hp: 25, maxHp: 25, attack: 3, defense: 1, speed: 0.02 };
      break;
  }

  const enemy = {
    x, y,
    targetX: x,
    targetY: y,
    type: enemyType,
    hp: stats.hp,
    maxHp: stats.maxHp,
    attack: stats.attack,
    defense: stats.defense,
    speed: stats.speed,
    range: stats.range,
    attackCooldown: 0,
    direction: 'down',
    isMoving: false,
    animationFrame: 0,
    animationTime: 0
  };

  gameState.enemies.push(enemy);
  playSound('enemySpawn', 0.3);

  // Ajouter un effet d'apparition
  addEffect('enemySpawn', x, y, 500);
}

// Ajouter un effet visuel
function addEffect(type, x, y, duration) {
  gameState.effectsQueue.push({
    type,
    x,
    y,
    startTime: gameState.gameTime,
    duration,
    frame: 0
  });
}

// Construction de b√¢timents
function buildStructure(type) {
  // D√©finir les co√ªts et dimensions des b√¢timents
  let buildingInfo = {
    width: 1,
    height: 1,
    woodCost: 0,
    stoneCost: 0,
    foodCost: 0,
    populationProvided: 0
  };

  switch(type) {
    case 'house':
      buildingInfo = {
        width: 2,
        height: 2,
        woodCost: 10,
        stoneCost: 0,
        populationProvided: 5
      };
      break;
    case 'farm':
      buildingInfo = {
        width: 2,
        height: 2,
        woodCost: 5,
        stoneCost: 3
      };
      break;
    case 'lumbermill':
      buildingInfo = {
        width: 2,
        height: 2,
        woodCost: 8,
        stoneCost: 5
      };
      break;
    case 'quarry':
      buildingInfo = {
        width: 2,
        height: 2,
        woodCost: 10,
        stoneCost: 5
      };
      break;
    case 'barracks':
      buildingInfo = {
        width: 3,
        height: 2,
        woodCost: 15,
        stoneCost: 10
      };
      break;
    case 'archery':
      buildingInfo = {
        width: 3,
        height: 2,
        woodCost: 15,
        stoneCost: 8
      };
      break;
    case 'towncenter':
      buildingInfo = {
        width: 4,
        height: 3,
        woodCost: 20,
        stoneCost: 15,
        populationProvided: 10
      };
      break;
  }

  // V√©rifier les ressources
  if (gameState.resources.wood < buildingInfo.woodCost ||
      gameState.resources.stone < buildingInfo.stoneCost ||
      gameState.resources.food < buildingInfo.foodCost) {
    updateStatus("Ressources insuffisantes pour construire");
    playSound('errorSound', 0.5);
    return;
  }

  // Activer le mode construction
  gameState.buildMode = {
    type,
    width: buildingInfo.width,
    height: buildingInfo.height,
    woodCost: buildingInfo.woodCost,
    stoneCost: buildingInfo.stoneCost,
    foodCost: buildingInfo.foodCost,
    populationProvided: buildingInfo.populationProvided
  };

  updateStatus(`S√©lectionnez un emplacement pour construire: ${getBuildingName(type)}`);
  playSound('buttonClick');
}

function getBuildingName(type) {
  switch(type) {
    case 'house': return 'Maison';
    case 'farm': return 'Ferme';
    case 'lumbermill': return 'Scierie';
    case 'quarry': return 'Carri√®re';
    case 'barracks': return 'Caserne';
    case 'archery': return 'Stand de tir';
    case 'towncenter': return 'H√¥tel de ville';
    default: return type;
  }
}

function placeBuildingAt(x, y, type, width, height, populationProvided = 0) {
  // V√©rifier si l'emplacement est valide
  for (let dy = 0; dy < height; dy++) {
    for (let dx = 0; dx < width; dx++) {
      if (x + dx >= config.mapWidth || y + dy >= config.mapHeight) {
        return false;
      }

      // V√©rifier les obstacles
      if (gameState.map[y + dy] && gameState.map[y + dy][x + dx]) {
        const tile = gameState.map[y + dy][x + dx];
        if (tile === 'water' || tile === 'mountain') {
          return false;
        }
      } else {
        return false;
      }

      // V√©rifier les ressources
      if (getResourceAt(x + dx, y + dy)) {
        return false;
      }

      // V√©rifier les autres b√¢timents
      if (gameState.buildings.some(b =>
        x + dx >= b.x && x + dx < b.x + b.width &&
        y + dy >= b.y && y + dy < b.y + b.height)) {
        return false;
      }
    }
  }

  // Si l'emplacement est valide, ajouter le b√¢timent
  const building = {
    x, y,
    width, height,
    type,
    hp: 100,
    maxHp: 100,
    productionTimer: 0,
    isConstructing: true,
    constructionProgress: 0,
    populationProvided
  };

  gameState.buildings.push(building);

  // Soustraire les ressources si on est en mode construction
  if (gameState.buildMode) {
    gameState.resources.wood -= gameState.buildMode.woodCost;
    gameState.resources.stone -= gameState.buildMode.stoneCost;
    gameState.resources.food -= gameState.buildMode.foodCost || 0;

    // Ajouter √† la population maximale si c'est une maison
    if (populationProvided > 0) {
      gameState.resources.maxPopulation += populationProvided;
    }

    gameState.buildMode = null;
  }

  updateUI();
  playSound('buildingPlace');

  // Ajouter un effet de construction
  for (let dy = 0; dy < height; dy++) {
    for (let dx = 0; dx < width; dx++) {
      addEffect('construction', x + dx, y + dy, 1000);
    }
  }

  return true;
}

// Mise √† jour du statut
function updateStatus(message) {
  statusBar.textContent = message;
}

// Mise √† jour de l'interface utilisateur
function updateUI() {
  document.getElementById('food').textContent = Math.floor(gameState.resources.food);
  document.getElementById('wood').textContent = Math.floor(gameState.resources.wood);
  document.getElementById('stone').textContent = Math.floor(gameState.resources.stone);
  document.getElementById('population').textContent = `${gameState.resources.population}/${gameState.resources.maxPopulation}`;

  // Mettre √† jour les boutons en fonction des ressources disponibles
  document.getElementById('villager-btn').disabled =
    gameState.resources.food < 5 ||
    gameState.resources.population >= gameState.resources.maxPopulation;

  document.getElementById('soldier-btn').disabled =
    gameState.resources.food < 10 ||
    gameState.resources.wood < 5 ||
    !gameState.buildings.some(b => b.type === 'barracks' && !b.isConstructing) ||
    gameState.resources.population >= gameState.resources.maxPopulation;

  document.getElementById('archer-btn').disabled =
    gameState.resources.food < 10 ||
    gameState.resources.wood < 10 ||
    !gameState.buildings.some(b => b.type === 'archery' && !b.isConstructing) ||
    gameState.resources.population >= gameState.resources.maxPopulation;

  document.getElementById('knight-btn').disabled =
    gameState.resources.food < 20 ||
    gameState.resources.stone < 15 ||
    !gameState.buildings.some(b => b.type === 'barracks' && !b.isConstructing) ||
    gameState.resources.population >= gameState.resources.maxPopulation;

  // B√¢timents
  document.getElementById('house-btn').disabled = gameState.resources.wood < 10;
  document.getElementById('farm-btn').disabled = gameState.resources.wood < 5 || gameState.resources.stone < 3;
  document.getElementById('lumbermill-btn').disabled = gameState.resources.wood < 8 || gameState.resources.stone < 5;
  document.getElementById('quarry-btn').disabled = gameState.resources.wood < 10 || gameState.resources.stone < 5;
  document.getElementById('barracks-btn').disabled = gameState.resources.wood < 15 || gameState.resources.stone < 10;
  document.getElementById('archery-btn').disabled = gameState.resources.wood < 15 || gameState.resources.stone < 8;
}

// Boucle de jeu principale
function gameLoop(timestamp) {
  // Calculer le delta time pour des animations fluides
  if (!gameState.lastFrameTime) {
    gameState.lastFrameTime = timestamp;
  }

  gameState.deltaTime = timestamp - gameState.lastFrameTime;
  gameState.lastFrameTime = timestamp;
  gameState.gameTime += gameState.deltaTime;

  // Mettre √† jour les unit√©s, b√¢timents, etc.
  updateGameState();

  // Dessiner tout
  draw();

  // Continuer la boucle
  window.requestAnimationFrame(gameLoop);
}

function updateGameState() {
  // Interpoler la cam√©ra pour un mouvement fluide
  gameState.camera.x += (gameState.camera.targetX - gameState.camera.x) * gameState.camera.speed;
  gameState.camera.y += (gameState.camera.targetY - gameState.camera.y) * gameState.camera.speed;

  // Mettre √† jour les unit√©s
  updateUnits();

  // Mettre √† jour les b√¢timents
  updateBuildings();

  // Mettre √† jour les ennemis
  updateEnemies();

  // Mettre √† jour les ressources automatiques
  collectAutomaticResources();

  // Mettre √† jour la visibilit√©
  if (config.fogOfWarEnabled) {
    updateRevealedMap();
  }

  // Nettoyer les effets expir√©s
  gameState.effectsQueue = gameState.effectsQueue.filter(
    effect => gameState.gameTime - effect.startTime < effect.duration
  );

  // Mettre √† jour les animations
  updateAnimations();
}

function updateUnits() {
  // Mise √† jour des villageois
  for (const villager of gameState.units.villagers) {
    // Animation
    villager.animationTime += gameState.deltaTime;
    if (villager.animationTime > 200) {
      villager.animationTime = 0;
      villager.animationFrame = (villager.animationFrame + 1) % 4;
    }

    // D√©placement
    if (villager.x !== villager.targetX || villager.y !== villager.targetY) {
      villager.isMoving = true;

      const dx = villager.targetX - villager.x;
      const dy = villager.targetY - villager.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // D√©terminer la direction du mouvement pour l'animation
      if (Math.abs(dx) > Math.abs(dy)) {
        villager.direction = dx > 0 ? 'right' : 'left';
      } else {
        villager.direction = dy > 0 ? 'down' : 'up';
      }

      if (dist < villager.speed) {
        villager.x = villager.targetX;
        villager.y = villager.targetY;
        villager.isMoving = false;
      } else {
        villager.x += (dx / dist) * villager.speed;
        villager.y += (dy / dist) * villager.speed;
      }
    } else {
      villager.isMoving = false;
    }

    // Collecte de ressources
    if (villager.task === 'gather' && villager.taskTarget) {
      const tx = Math.floor(villager.taskTarget.x);
      const ty = Math.floor(villager.taskTarget.y);
      const vx = Math.floor(villager.x);
      const vy = Math.floor(villager.y);

      // Si √† proximit√© de la ressource
      if (Math.abs(vx - tx) <= 1 && Math.abs(vy - ty) <= 1) {
        // Orienter le villageois vers la ressource
        if (vx < tx) villager.direction = 'right';
        else if (vx > tx) villager.direction = 'left';
        else if (vy < ty) villager.direction = 'down';
        else villager.direction = 'up';

        // Collecter la ressource progressivement
        villager.taskTarget.gatherProgress = (villager.taskTarget.gatherProgress || 0) + gameState.deltaTime;

        if (villager.taskTarget.gatherProgress >= config.resourceGatherInterval) {
          villager.taskTarget.gatherProgress = 0;

          if (villager.taskTarget.resources > 0) {
            // Ajouter la ressource aux stocks
            if (villager.taskTarget.type === 'wood') {
              gameState.resources.wood += config.resourceGatherRate;
              playSound('treeChop', 0.3);
            } else if (villager.taskTarget.type === 'stone') {
              gameState.resources.stone += config.resourceGatherRate;
              playSound('rockMine', 0.3);
            } else if (villager.taskTarget.type === 'food') {
              gameState.resources.food += config.resourceGatherRate;
              playSound('berryPick', 0.3);
            }

            // Diminuer la ressource
            villager.taskTarget.resources -= config.resourceGatherRate;

            // Ajouter un indicateur de ressource r√©colt√©e
            addResourceIndicator(villager.x, villager.y, villager.taskTarget.type, config.resourceGatherRate);

            // Si la ressource est √©puis√©e
            if (villager.taskTarget.resources <= 0) {
              // Ajouter un effet de destruction
              addEffect(
                villager.taskTarget.type === 'wood' ? 'treeDestruction' :
                villager.taskTarget.type === 'stone' ? 'stoneDestruction' :
                'berryDepletion',
                villager.taskTarget.x,
                villager.taskTarget.y,
                1000
              );

              // R√©initialiser la t√¢che
              villager.task = null;
              villager.taskTarget = null;
            }

            updateUI();
          }
        }
      }
    }

    // Construction
    if (villager.task === 'build' && villager.taskTarget) {
      const bx = villager.taskTarget.x + villager.taskTarget.width / 2;
      const by = villager.taskTarget.y + villager.taskTarget.height / 2;
      const dist = distance(villager.x, villager.y, bx, by);

      // Si √† proximit√© du b√¢timent
      if (dist <= 1.5) {
        // Orienter le villageois vers le b√¢timent
        if (villager.x < bx) villager.direction = 'right';
        else if (villager.x > bx) villager.direction = 'left';
        else if (villager.y < by) villager.direction = 'down';
        else villager.direction = 'up';

        // Construire progressivement
        villager.taskTarget.constructionProgress += gameState.deltaTime / 20;

        // Si la construction est termin√©e
        if (villager.taskTarget.constructionProgress >= 100) {
          villager.taskTarget.isConstructing = false;
          villager.task = null;
          villager.taskTarget = null;
          playSound('buildingPlace', 0.7);

          // Ajouter un effet de construction termin√©e
          addEffect('constructionComplete', bx, by, 1000);
        }
      }
    }

    // Auto-d√©fense contre les ennemis proches
    if (!villager.task || villager.task !== 'attack') {
      for (const enemy of gameState.enemies) {
        if (distance(villager.x, villager.y, enemy.x, enemy.y) < 0.8) {
          // Attaquer automatiquement l'ennemi
          if (villager.attackCooldown <= 0) {
            // Infliger des d√©g√¢ts
            enemy.hp -= Math.max(1, config.villagerDamage - enemy.defense);
            villager.attackCooldown = 1000; // 1 seconde

            // Effet d'attaque
            addEffect('attack', enemy.x, enemy.y, 300);
            playSound('villagerHarvest', 0.3);

            // V√©rifier si l'ennemi est mort
            if (enemy.hp <= 0) {
              const index = gameState.enemies.indexOf(enemy);
              if (index !== -1) {
                gameState.enemies.splice(index, 1);
                addEffect('enemyDeath', enemy.x, enemy.y, 500);
                playSound('enemyDeath', 0.5);
              }
            }
          }
          break;
        }
      }
    }

    // Mettre √† jour le temps de recharge d'attaque
    if (villager.attackCooldown > 0) {
      villager.attackCooldown -= gameState.deltaTime;
    }
  }

  // Mise √† jour des soldats, archers et chevaliers de fa√ßon similaire
  updateCombatUnits(gameState.units.soldiers, 'soldier');
  updateCombatUnits(gameState.units.archers, 'archer');
  updateCombatUnits(gameState.units.knights, 'knight');
}

function updateCombatUnits(units, unitType) {
  for (const unit of units) {
    // Animation
    unit.animationTime += gameState.deltaTime;
    if (unit.animationTime > 200) {
      unit.animationTime = 0;
      unit.animationFrame = (unit.animationFrame + 1) % 4;
    }

    // D√©placement
    if (unit.x !== unit.targetX || unit.y !== unit.targetY) {
      unit.isMoving = true;

      const dx = unit.targetX - unit.x;
      const dy = unit.targetY - unit.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // D√©terminer la direction du mouvement pour l'animation
      if (Math.abs(dx) > Math.abs(dy)) {
        unit.direction = dx > 0 ? 'right' : 'left';
      } else {
        unit.direction = dy > 0 ? 'down' : 'up';
      }

      if (dist < unit.speed) {
        unit.x = unit.targetX;
        unit.y = unit.targetY;
        unit.isMoving = false;
      } else {
        unit.x += (dx / dist) * unit.speed;
        unit.y += (dy / dist) * unit.speed;
      }
    } else {
      unit.isMoving = false;
    }

    // Attaque automatique des ennemis √† proximit√©
    if (gameState.enemies.length > 0) {
      let closestEnemy = null;
      let closestDist = unitType === 'archer' ? unit.range : 1.5;

      for (const enemy of gameState.enemies) {
        const dist = distance(unit.x, unit.y, enemy.x, enemy.y);
        if (dist < closestDist) {
          closestEnemy = enemy;
          closestDist = dist;
        }
      }

      if (closestEnemy) {
        // Orienter l'unit√© vers l'ennemi
        const dx = closestEnemy.x - unit.x;
        const dy = closestEnemy.y - unit.y;

        if (Math.abs(dx) > Math.abs(dy)) {
          unit.direction = dx > 0 ? 'right' : 'left';
        } else {
          unit.direction = dy > 0 ? 'down' : 'up';
        }

        // Attaquer si le temps de recharge est √©coul√©
        if (unit.attackCooldown <= 0) {
          // D√©terminer les d√©g√¢ts selon le type d'unit√©
          let damage = 0;
          switch (unitType) {
            case 'soldier': damage = config.soldierDamage; break;
            case 'archer': damage = config.archerDamage; break;
            case 'knight': damage = config.knightDamage; break;
          }

          // Infliger des d√©g√¢ts
          closestEnemy.hp -= Math.max(1, damage - closestEnemy.defense);

          // R√©initialiser le temps de recharge
          unit.attackCooldown = unitType === 'archer' ? 1500 : 1000;

          // Effet d'attaque
          addEffect('attack', closestEnemy.x, closestEnemy.y, 300);
          playSound('soldierAttack', 0.3);

          // V√©rifier si l'ennemi est mort
          if (closestEnemy.hp <= 0) {
            const index = gameState.enemies.indexOf(closestEnemy);
            if (index !== -1) {
              gameState.enemies.splice(index, 1);
              addEffect('enemyDeath', closestEnemy.x, closestEnemy.y, 500);
              playSound('enemyDeath', 0.5);
            }
          }
        }
      }
    }

    // Mettre √† jour le temps de recharge d'attaque
    if (unit.attackCooldown > 0) {
      unit.attackCooldown -= gameState.deltaTime;
    }
  }
}

function updateBuildings() {
  for (const building of gameState.buildings) {
    // Si le b√¢timent est en construction, pas de production
    if (building.isConstructing) continue;

    // Production automatique selon le type de b√¢timent
    switch (building.type) {
      case 'farm':
        building.productionTimer += gameState.deltaTime;
        if (building.productionTimer >= 5000) { // 5 secondes
          gameState.resources.food += 2;
          building.productionTimer = 0;
          addResourceIndicator(building.x + building.width / 2, building.y + building.height / 2, 'food', 2);
          updateUI();
        }
        break;

      case 'lumbermill':
        building.productionTimer += gameState.deltaTime;
        if (building.productionTimer >= 8000) { // 8 secondes
          gameState.resources.wood += 1;
          building.productionTimer = 0;
          addResourceIndicator(building.x + building.width / 2, building.y + building.height / 2, 'wood', 1);
          updateUI();
        }
        break;

      case 'quarry':
        building.productionTimer += gameState.deltaTime;
        if (building.productionTimer >= 10000) { // 10 secondes
          gameState.resources.stone += 1;
          building.productionTimer = 0;
          addResourceIndicator(building.x + building.width / 2, building.y + building.height / 2, 'stone', 1);
          updateUI();
        }
        break;
    }
  }
}

function updateEnemies() {
  for (let i = gameState.enemies.length - 1; i >= 0; i--) {
    const enemy = gameState.enemies[i];

    // Animation
    enemy.animationTime += gameState.deltaTime;
    if (enemy.animationTime > 200) {
      enemy.animationTime = 0;
      enemy.animationFrame = (enemy.animationFrame + 1) % 4;
    }

    // Trouver la cible la plus proche
    let closestTarget = null;
    let closestDist = Infinity;

    // V√©rifier les b√¢timents d'abord
    for (const building of gameState.buildings) {
      if (building.isConstructing) continue; // Ignorer les b√¢timents en construction

      const bx = building.x + building.width / 2;
      const by = building.y + building.height / 2;
      const dist = distance(enemy.x, enemy.y, bx, by);

      if (dist < closestDist) {
        closestTarget = { type: 'building', obj: building, x: bx, y: by };
        closestDist = dist;
      }
    }

    // Ensuite v√©rifier toutes les unit√©s
    const allUnits = [
      ...gameState.units.villagers,
      ...gameState.units.soldiers,
      ...gameState.units.archers,
      ...gameState.units.knights
    ];

    for (const unit of allUnits) {
      const dist = distance(enemy.x, enemy.y, unit.x, unit.y);
      if (dist < closestDist) {
        closestTarget = { type: 'unit', obj: unit, x: unit.x, y: unit.y };
        closestDist = dist;
      }
    }

    // Si une cible est trouv√©e
    if (closestTarget) {
      // D√©placement vers la cible
      if (closestDist > enemy.range) {
        enemy.isMoving = true;

        // Calculer la direction vers la cible
        const dx = closestTarget.x - enemy.x;
        const dy = closestTarget.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // D√©terminer la direction du mouvement pour l'animation
        if (Math.abs(dx) > Math.abs(dy)) {
          enemy.direction = dx > 0 ? 'right' : 'left';
        } else {
          enemy.direction = dy > 0 ? 'down' : 'up';
        }

        // D√©placer l'ennemi
        enemy.x += (dx / dist) * enemy.speed;
        enemy.y += (dy / dist) * enemy.speed;
      } else {
        enemy.isMoving = false;

        // Orienter l'ennemi vers la cible
        const dx = closestTarget.x - enemy.x;
        const dy = closestTarget.y - enemy.y;

        if (Math.abs(dx) > Math.abs(dy)) {
          enemy.direction = dx > 0 ? 'right' : 'left';
        } else {
          enemy.direction = dy > 0 ? 'down' : 'up';
        }

        // Attaquer si le temps de recharge est √©coul√©
        if (enemy.attackCooldown <= 0) {
          if (closestTarget.type === 'building') {
            closestTarget.obj.hp -= Math.max(1, enemy.attack);

            // V√©rifier si le b√¢timent est d√©truit
            if (closestTarget.obj.hp <= 0) {
              // Si c'est une maison, r√©duire la population maximale
              if (closestTarget.obj.type === 'house') {
                gameState.resources.maxPopulation -= closestTarget.obj.populationProvided;
              }

              const index = gameState.buildings.indexOf(closestTarget.obj);
              if (index !== -1) {
                gameState.buildings.splice(index, 1);
                addEffect('buildingDestroy', closestTarget.x, closestTarget.y, 1000);
                playSound('buildingDestroy', 0.6);
              }

              updateUI();
            }
          } else {
            closestTarget.obj.hp -= Math.max(1, enemy.attack - closestTarget.obj.defense);

            // V√©rifier si l'unit√© est morte
            if (closestTarget.obj.hp <= 0) {
              let unitArray;
              switch (closestTarget.obj.type) {
                case 'villager': unitArray = gameState.units.villagers; break;
                case 'soldier': unitArray = gameState.units.soldiers; break;
                case 'archer': unitArray = gameState.units.archers; break;
                case 'knight': unitArray = gameState.units.knights; break;
              }

              const index = unitArray.indexOf(closestTarget.obj);
              if (index !== -1) {
                unitArray.splice(index, 1);
                gameState.resources.population--;
                addEffect('unitDeath', closestTarget.x, closestTarget.y, 500);
                updateUI();
              }
            }
          }

          // R√©initialiser le temps de recharge
          enemy.attackCooldown = 1000;

          // Effet d'attaque
          addEffect('enemyAttack', closestTarget.x, closestTarget.y, 300);
        }
      }
    } else {
      // Pas de cible, se d√©placer al√©atoirement
      if (Math.random() < 0.01) {
        enemy.targetX = Math.max(0, Math.min(config.mapWidth - 1, enemy.x + (Math.random() * 10 - 5)));
        enemy.targetY = Math.max(0, Math.min(config.mapHeight - 1, enemy.y + (Math.random() * 10 - 5)));
      }

      if (enemy.x !== enemy.targetX || enemy.y !== enemy.targetY) {
        enemy.isMoving = true;

        const dx = enemy.targetX - enemy.x;
        const dy = enemy.targetY - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (Math.abs(dx) > Math.abs(dy)) {
          enemy.direction = dx > 0 ? 'right' : 'left';
        } else {
          enemy.direction = dy > 0 ? 'down' : 'up';
        }

        if (dist < enemy.speed) {
          enemy.x = enemy.targetX;
          enemy.y = enemy.targetY;
          enemy.isMoving = false;
        } else {
          enemy.x += (dx / dist) * enemy.speed;
          enemy.y += (dy / dist) * enemy.speed;
        }
      } else {
        enemy.isMoving = false;
      }
    }

    // Mettre √† jour le temps de recharge d'attaque
    if (enemy.attackCooldown > 0) {
      enemy.attackCooldown -= gameState.deltaTime;
    }
  }
}

function addResourceIndicator(x, y, type, amount) {
  // Cr√©er un √©l√©ment div pour l'indicateur
  const indicator = document.createElement('div');
  indicator.className = 'resource-indicator';

  // D√©finir le contenu selon le type de ressource
  let icon;
  switch (type) {
    case 'food': icon = 'üåæ'; break;
    case 'wood': icon = 'ü™µ'; break;
    case 'stone': icon = '‚õèÔ∏è'; break;
    default: icon = '+';
  }

  indicator.textContent = `${icon} +${amount}`;

  // Positionner l'indicateur
  const screenX = Math.floor((x * config.tileSize) - gameState.camera.x);
  const screenY = Math.floor((y * config.tileSize) - gameState.camera.y);

  indicator.style.left = `${screenX}px`;
  indicator.style.top = `${screenY}px`;

  // Ajouter l'indicateur au DOM
  document.getElementById('ui-overlay').appendChild(indicator);

  // Supprimer l'indicateur apr√®s l'animation
  setTimeout(() => {
    indicator.remove();
  }, 1500);
}

function collectAutomaticResources() {
  // Cette fonction g√®re les ressources g√©n√©r√©es automatiquement par certains b√¢timents
  // La logique est d√©j√† impl√©ment√©e dans updateBuildings
}

function updateAnimations() {
  // Cette fonction met √† jour les frames d'animation pour les unit√©s et effets
  // La logique est d√©j√† impl√©ment√©e dans les fonctions respectives
}

// Dessiner le jeu
function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Dessiner la carte
  drawMap();

  // Dessiner les b√¢timents
  drawBuildings();

  // Dessiner les unit√©s
  drawUnits();

  // Dessiner les ennemis
  drawEnemies();

  // Dessiner les effets
  drawEffects();

  // Dessiner l'interface utilisateur
  drawUI();

  // Dessiner la mini-carte
  drawMinimap();
}

function drawMap() {
  const tileSize = config.tileSize;

  // Calculer la zone visible
  const startX = Math.floor(gameState.camera.x / tileSize);
  const startY = Math.floor(gameState.camera.y / tileSize);
  const endX = Math.min(config.mapWidth, startX + Math.ceil(canvas.width / tileSize) + 1);
  const endY = Math.min(config.mapHeight, startY + Math.ceil(canvas.height / tileSize) + 1);

  // Dessiner le terrain
  for (let y = startY; y < endY; y++) {
    for (let x = startX; x < endX; x++) {
      // Si en dehors de la carte, continuer
      if (y >= gameState.map.length || x >= gameState.map[y].length) continue;

      const screenX = x * tileSize - gameState.camera.x;
      const screenY = y * tileSize - gameState.camera.y;

      // Obtenir le type de terrain
      const tile = gameState.map[y][x];

      // D√©finir la couleur selon le type
      switch (tile) {
        case 'grass':
          ctx.fillStyle = (x + y) % 2 === 0 ? '#3a5' : '#294';
          break;
        case 'water':
          ctx.fillStyle = '#39f';
          break;
        case 'sand':
          ctx.fillStyle = '#da3';
          break;
        case 'stone':
          ctx.fillStyle = '#777';
          break;
        case 'mountain':
          ctx.fillStyle = '#961';
          break;
        default:
          ctx.fillStyle = '#3a5';
      }

      // Dessiner la tuile
      ctx.fillRect(screenX, screenY, tileSize, tileSize);

      // Dessiner les ressources √† cette position
      const tree = gameState.trees.find(t => t.x === x && t.y === y && t.resources > 0);
      if (tree) {
        ctx.fillStyle = '#063';
        ctx.beginPath();
        ctx.arc(screenX + tileSize / 2, screenY + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
        ctx.fill();
      }

      const stone = gameState.stones.find(s => s.x === x && s.y === y && s.resources > 0);
      if (stone) {
        ctx.fillStyle = '#999';
        ctx.fillRect(screenX + tileSize / 4, screenY + tileSize / 4, tileSize / 2, tileSize / 2);
      }

      const berry = gameState.berries.find(b => b.x === x && b.y === y && b.resources > 0);
      if (berry) {
        ctx.fillStyle = '#e44';
        ctx.beginPath();
        ctx.arc(screenX + tileSize / 2, screenY + tileSize / 2, tileSize / 4, 0, Math.PI * 2);
        ctx.fill();
      }
    }
  }
}

function drawBuildings() {
  const tileSize = config.tileSize;

  for (const building of gameState.buildings) {
    const screenX = Math.floor(building.x * tileSize - gameState.camera.x);
    const screenY = Math.floor(building.y * tileSize - gameState.camera.y);
    const width = building.width * tileSize;
    const height = building.height * tileSize;

    // Si hors √©cran, ne pas dessiner
    if (screenX + width < 0 || screenX > canvas.width ||
        screenY + height < 0 || screenY > canvas.height) {
      continue;
    }

    // Couleur selon le type de b√¢timent
    let color;
    switch(building.type) {
      case 'house': color = '#b94'; break;
      case 'farm': color = '#b80'; break;
      case 'lumbermill': color = '#851'; break;
      case 'barracks': color = '#755'; break;
      default: color = '#aaa';
    }

    // Construction en cours
    if (building.isConstructing) {
      ctx.globalAlpha = 0.5 + (building.constructionProgress / 200);
      ctx.fillStyle = color;
      ctx.fillRect(screenX, screenY, width, height);

      // Bordure
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(screenX, screenY, width, height);

      // Barre de progression
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(screenX, screenY + height - 8, width, 8);
      ctx.fillStyle = 'rgba(0, 255, 0, 0.7)';
      ctx.fillRect(screenX, screenY + height - 8, width * (building.constructionProgress / 100), 8);

      ctx.globalAlpha = 1.0;
    } else {
      // B√¢timent termin√©
      ctx.fillStyle = color;
      ctx.fillRect(screenX, screenY, width, height);

      // Bordure
      ctx.strokeStyle = '#fff';
      ctx.lineWidth = 2;
      ctx.strokeRect(screenX, screenY, width, height);

      // Symbole du b√¢timent
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';

      let symbol = '';
      switch(building.type) {
        case 'house': symbol = 'üè†'; break;
        case 'farm': symbol = 'üåæ'; break;
        case 'lumbermill': symbol = 'ü™ì'; break;
        case 'barracks': symbol = '‚öîÔ∏è'; break;
      }

      ctx.fillText(symbol, screenX + width / 2, screenY + height / 2);
    }

    // Barre de vie
    const healthPercentage = building.hp / building.maxHp;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(screenX + 2, screenY + height + 2, width - 4, 6);
    ctx.fillStyle = healthPercentage > 0.6 ? 'rgba(0, 255, 0, 0.7)' :
                   healthPercentage > 0.3 ? 'rgba(255, 255, 0, 0.7)' :
                   'rgba(255, 0, 0, 0.7)';
    ctx.fillRect(screenX + 2, screenY + height + 2, (width - 4) * healthPercentage, 6);
  }
}

function drawUnitType(units, type) {
  const tileSize = config.tileSize;

  for (const unit of units) {
    const screenX = Math.floor(unit.x * tileSize - gameState.camera.x);
    const screenY = Math.floor(unit.y * tileSize - gameState.camera.y);

    // Si hors √©cran, ne pas dessiner
    if (screenX + tileSize < 0 || screenX > canvas.width ||
        screenY + tileSize < 0 || screenY > canvas.height) {
      continue;
    }

    // Dessiner selon le type d'unit√©
    if (type === 'villager') {
      // Villageois (cercle)
      ctx.fillStyle = unit.selected ? '#6cf' : '#fff';
      ctx.beginPath();
      ctx.arc(screenX + tileSize / 2, screenY + tileSize / 2, tileSize / 3, 0, Math.PI * 2);
      ctx.fill();
    } else {
      // Soldat (carr√©)
      ctx.fillStyle = unit.selected ? '#6cf' : '#ccc';
      ctx.fillRect(screenX + 6, screenY + 6, tileSize - 12, tileSize - 12);
    }

    // Barre de vie
    const healthPercentage = unit.hp / unit.maxHp;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(screenX + 5, screenY - 8, tileSize - 10, 4);
    ctx.fillStyle = healthPercentage > 0.6 ? 'rgba(0, 255, 0, 0.7)' :
                   healthPercentage > 0.3 ? 'rgba(255, 255, 0, 0.7)' :
                   'rgba(255, 0, 0, 0.7)';
    ctx.fillRect(screenX + 5, screenY - 8, (tileSize - 10) * healthPercentage, 4);

    // Cercle de s√©lection
    if (unit.selected) {
      ctx.strokeStyle = '#6cf';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(screenX + tileSize / 2, screenY + tileSize / 2, tileSize / 2, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Ic√¥ne de t√¢che
    if (unit.task) {
      ctx.fillStyle = '#fff';
      ctx.textAlign = 'center';
      let icon = '';
      switch(unit.task) {
        case 'gather': icon = '‚õèÔ∏è'; break;
        case 'build': icon = 'üî®'; break;
        case 'attack': icon = '‚öîÔ∏è'; break;
      }
      ctx.fillText(icon, screenX + tileSize / 2, screenY - 12);
    }
  }
}

function drawEnemies() {
  const tileSize = config.tileSize;

  for (const enemy of gameState.enemies) {
    const screenX = Math.floor(enemy.x * tileSize - gameState.camera.x);
    const screenY = Math.floor(enemy.y * tileSize - gameState.camera.y);

    // V√©rifier si l'ennemi est dans la zone visible
    if (screenX + tileSize < 0 || screenX > canvas.width ||
        screenY + tileSize < 0 || screenY > canvas.height) {
      continue;
    }

    // V√©rifier si l'ennemi est visible (brouillard de guerre)
    const enemyX = Math.floor(enemy.x);
    const enemyY = Math.floor(enemy.y);

    if (config.fogOfWarEnabled &&
        (enemyY < 0 || enemyY >= config.mapHeight ||
         enemyX < 0 || enemyX >= config.mapWidth ||
         gameState.revealedMap[enemyY][enemyX] === 0)) {
      continue;
    }

    // Dessiner l'ennemi
    const enemyImage = resourceCache.images.enemy;
    ctx.drawImage(enemyImage, screenX, screenY, tileSize, tileSize);

    // Dessiner la barre de vie
    const healthBarWidth = tileSize - 10;
    const healthPercentage = enemy.hp / enemy.maxHp;

    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(screenX + 5, screenY - 10, healthBarWidth, 5);

    ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
    ctx.fillRect(screenX + 5, screenY - 10, healthBarWidth * healthPercentage, 5);

    // Si l'ennemi est visible mais en brouillard de guerre explor√©
    if (config.fogOfWarEnabled && gameState.revealedMap[enemyY][enemyX] === 1) {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
      ctx.fillRect(screenX, screenY, tileSize, tileSize);
    }
  }
}

function drawEffects() {
  const tileSize = config.tileSize;

  for (const effect of gameState.effectsQueue) {
    const screenX = Math.floor(effect.x * tileSize - gameState.camera.x);
    const screenY = Math.floor(effect.y * tileSize - gameState.camera.y);

    // V√©rifier si l'effet est dans la zone visible
    if (screenX + tileSize < 0 || screenX > canvas.width ||
        screenY + tileSize < 0 || screenY > canvas.height) {
      continue;
    }

    // Calculer la progression de l'effet
    const progress = (gameState.gameTime - effect.startTime) / effect.duration;

    // Dessiner l'effet selon son type
    switch (effect.type) {
      case 'spawn':
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
        ctx.beginPath();
        ctx.arc(
          screenX + tileSize / 2,
          screenY + tileSize / 2,
          tileSize * progress,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.globalAlpha = 1.0;
        break;

      case 'enemySpawn':
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.beginPath();
        ctx.arc(
          screenX + tileSize / 2,
          screenY + tileSize / 2,
          tileSize * progress,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.globalAlpha = 1.0;
        break;

      case 'attack':
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = 'rgba(255, 255, 0, 0.6)';
        ctx.beginPath();
        ctx.arc(
          screenX + tileSize / 2,
          screenY + tileSize / 2,
          tileSize / 3 * progress,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.globalAlpha = 1.0;
        break;

      case 'enemyAttack':
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = 'rgba(255, 0, 0, 0.6)';
        ctx.beginPath();
        ctx.arc(
          screenX + tileSize / 2,
          screenY + tileSize / 2,
          tileSize / 3 * progress,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.globalAlpha = 1.0;
        break;

      case 'enemyDeath':
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = 'rgba(255, 0, 0, 0.8)';
        ctx.beginPath();
        for (let i = 0; i < 8; i++) {
          const angle = (i / 8) * Math.PI * 2;
          const distance = tileSize * progress;
          const particleX = screenX + tileSize / 2 + Math.cos(angle) * distance;
          const particleY = screenY + tileSize / 2 + Math.sin(angle) * distance;
          ctx.moveTo(screenX + tileSize / 2, screenY + tileSize / 2);
          ctx.lineTo(particleX, particleY);
        }
        ctx.stroke();
        ctx.globalAlpha = 1.0;
        break;

      case 'construction':
        const constructionImage = resourceCache.images.constructionEffect;
        ctx.globalAlpha = 0.7;
        ctx.drawImage(
          constructionImage,
          screenX,
          screenY,
          tileSize,
          tileSize
        );
        ctx.globalAlpha = 1.0;
        break;

      case 'constructionComplete':
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
        ctx.beginPath();
        ctx.arc(
          screenX + tileSize / 2,
          screenY + tileSize / 2,
          tileSize * 2 * progress,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.globalAlpha = 1.0;
        break;

      case 'treeDestruction':
        ctx.globalAlpha = 1 - progress;
        ctx.fillStyle = 'rgba(139, 69, 19, 0.6)';
        for (let i = 0; i < 5; i++) {
          const angle = (i / 5) * Math.PI * 2 + progress * Math.PI;
          const distanceX = (Math.random() * 10 + 10) * progress;
          const distanceY = (Math.random() * 5 + 15) * progress;
          const particleX = screenX + tileSize / 2 + Math.cos(angle) * distanceX;
          const particleY = screenY + tileSize / 2 - distanceY;
          ctx.fillRect(particleX, particleY, 3, 3);
        }
        ctx.globalAlpha = 1.0;
        break;
    }
  }
}

function drawUI() {
  // Dessiner la bo√Æte de s√©lection
  if (gameState.selectionBox) {
    const { startX, startY, endX, endY } = gameState.selectionBox;
    const boxX = Math.min(startX, endX);
    const boxY = Math.min(startY, endY);
    const boxWidth = Math.abs(endX - startX);
    const boxHeight = Math.abs(endY - startY);

    ctx.strokeStyle = 'rgba(100, 200, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.strokeRect(boxX, boxY, boxWidth, boxHeight);
    ctx.fillStyle = 'rgba(100, 200, 255, 0.1)';
    ctx.fillRect(boxX, boxY, boxWidth, boxHeight);
  }

  // Dessiner le mode construction (aper√ßu du b√¢timent)
  if (gameState.buildMode) {
    const tileSize = config.tileSize;
    const mouseX = Math.floor((lastMouseX + gameState.camera.x) / tileSize);
    const mouseY = Math.floor((lastMouseY + gameState.camera.y) / tileSize);
    const screenX = Math.floor(mouseX * tileSize - gameState.camera.x);
    const screenY = Math.floor(mouseY * tileSize - gameState.camera.y);
    const width = gameState.buildMode.width * tileSize;
    const height = gameState.buildMode.height * tileSize;

    // V√©rifier si l'emplacement est valide
    let isValid = true;
    for (let dy = 0; dy < gameState.buildMode.height; dy++) {
      for (let dx = 0; dx < gameState.buildMode.width; dx++) {
        if (mouseX + dx >= config.mapWidth || mouseY + dy >= config.mapHeight) {
          isValid = false;
          break;
        }

        // V√©rifier les obstacles
        if (mouseY + dy < config.mapHeight && mouseX + dx < config.mapWidth) {
          const tile = gameState.map[mouseY + dy][mouseX + dx];
          if (tile === 'water' || tile === 'mountain') {
            isValid = false;
            break;
          }

          // V√©rifier les ressources
          if (getResourceAt(mouseX + dx, mouseY + dy)) {
            isValid = false;
            break;
          }

          // V√©rifier les autres b√¢timents
          if (gameState.buildings.some(b =>
            mouseX + dx >= b.x && mouseX + dx < b.x + b.width &&
            mouseY + dy >= b.y && mouseY + dy < b.y + b.height)) {
            isValid = false;
            break;
          }
        } else {
          isValid = false;
        }
      }
    }

    // Dessiner l'aper√ßu du b√¢timent
    ctx.globalAlpha = 0.7;
    let buildingImage = null;

    switch (gameState.buildMode.type) {
      case 'house': buildingImage = resourceCache.images.house; break;
      case 'farm': buildingImage = resourceCache.images.farm; break;
      case 'lumbermill': buildingImage = resourceCache.images.lumbermill; break;
      case 'quarry': buildingImage = resourceCache.images.quarry; break;
      case 'barracks': buildingImage = resourceCache.images.barracks; break;
      case 'archery': buildingImage = resourceCache.images.archery; break;
      case 'towncenter': buildingImage = resourceCache.images.towncenter; break;
    }

    if (buildingImage) {
      ctx.drawImage(buildingImage, screenX, screenY, width, height);
    }

    // Dessiner un rectangle color√© pour indiquer la validit√©
    ctx.fillStyle = isValid ? 'rgba(0, 255, 0, 0.3)' : 'rgba(255, 0, 0, 0.3)';
    ctx.fillRect(screenX, screenY, width, height);

    ctx.strokeStyle = isValid ? 'rgba(0, 255, 0, 0.8)' : 'rgba(255, 0, 0, 0.8)';
    ctx.lineWidth = 2;
    ctx.strokeRect(screenX, screenY, width, height);
    ctx.globalAlpha = 1.0;
  }
}

function drawMinimap() {
  minimapCtx.clearRect(0, 0, minimap.width, minimap.height);

  // Dessiner le fond
  minimapCtx.fillStyle = '#000';
  minimapCtx.fillRect(0, 0, minimap.width, minimap.height);

  // Calculer l'√©chelle
  const scaleX = minimap.width / (config.mapWidth * config.tileSize);
  const scaleY = minimap.height / (config.mapHeight * config.tileSize);

  // Dessiner la carte
  for (let y = 0; y < config.mapHeight; y++) {
    for (let x = 0; x < config.mapWidth; x++) {
      // V√©rifier si la tuile est r√©v√©l√©e
      if (config.fogOfWarEnabled && gameState.revealedMap[y][x] === 0) {
        continue;
      }

      const tile = gameState.map[y][x];
      let color;

      switch (tile) {
        case 'grass': color = '#3a3'; break;
        case 'water': color = '#33f'; break;
        case 'sand': color = '#da3'; break;
        case 'stone': color = '#777'; break;
        case 'mountain': color = '#961'; break;
        case 'dirt': color = '#961'; break;
        default: color = '#3a3';
      }

      const miniX = x * config.tileSize * scaleX;
      const miniY = y * config.tileSize * scaleY;
      const miniSize = Math.max(1, config.tileSize * scaleX);

      minimapCtx.fillStyle = color;
      minimapCtx.fillRect(miniX, miniY, miniSize, miniSize);

      // Appliquer l'effet de brouillard de guerre en mode explor√©
      if (config.fogOfWarEnabled && gameState.revealedMap[y][x] === 1) {
        minimapCtx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        minimapCtx.fillRect(miniX, miniY, miniSize, miniSize);
      }
    }
  }

  // Dessiner les b√¢timents
  for (const building of gameState.buildings) {
    const miniX = building.x * config.tileSize * scaleX;
    const miniY = building.y * config.tileSize * scaleY;
    const miniWidth = building.width * config.tileSize * scaleX;
    const miniHeight = building.height * config.tileSize * scaleY;

    minimapCtx.fillStyle = '#66f';
    minimapCtx.fillRect(miniX, miniY, miniWidth, miniHeight);
  }

  // Dessiner les unit√©s
  // Villageois
  for (const villager of gameState.units.villagers) {
    minimapCtx.fillStyle = '#fff';
    minimapCtx.fillRect(
      villager.x * config.tileSize * scaleX - 1,
      villager.y * config.tileSize * scaleY - 1,
      3, 3
    );
  }

  // Soldats, archers et chevaliers
  for (const soldier of gameState.units.soldiers) {
    minimapCtx.fillStyle = '#0ff';
    minimapCtx.fillRect(
      soldier.x * config.tileSize * scaleX - 1,
      soldier.y * config.tileSize * scaleY - 1,
      3, 3
    );
  }

  for (const archer of gameState.units.archers) {
    minimapCtx.fillStyle = '#ff0';
    minimapCtx.fillRect(
      archer.x * config.tileSize * scaleX - 1,
      archer.y * config.tileSize * scaleY - 1,
      3, 3
    );
  }

  for (const knight of gameState.units.knights) {
    minimapCtx.fillStyle = '#f0f';
    minimapCtx.fillRect(
      knight.x * config.tileSize * scaleX - 1,
      knight.y * config.tileSize * scaleY - 1,
      3, 3
    );
  }

  // Dessiner les ennemis
  for (const enemy of gameState.enemies) {
    minimapCtx.fillStyle = '#f00';
    minimapCtx.fillRect(
      enemy.x * config.tileSize * scaleX - 1,
      enemy.y * config.tileSize * scaleY - 1,
      3, 3
    );
  }

  // Dessiner la zone de cam√©ra
  const cameraX = gameState.camera.x * scaleX;
  const cameraY = gameState.camera.y * scaleY;
  const cameraWidth = canvas.width * scaleX;
  const cameraHeight = canvas.height * scaleY;

  minimapCtx.strokeStyle = '#fff';
  minimapCtx.lineWidth = 1;
  minimapCtx.strokeRect(cameraX, cameraY, cameraWidth, cameraHeight);
}

// √âv√©nements de souris et entr√©es utilisateur
let lastMouseX = 0, lastMouseY = 0;

canvas.addEventListener('mousedown', handleMouseDown);
canvas.addEventListener('mousemove', handleMouseMove);
canvas.addEventListener('mouseup', handleMouseUp);
canvas.addEventListener('contextmenu', e => e.preventDefault());
minimap.addEventListener('mousedown', handleMinimapClick);
window.addEventListener('keydown', handleKeyDown);

// Pour les infobulles
document.querySelectorAll('button').forEach(btn => {
  btn.addEventListener('mouseenter', showTooltip);
  btn.addEventListener('mouseleave', hideTooltip);
});

function handleMouseDown(e) {
  const x = e.offsetX;
  const y = e.offsetY;
  lastMouseX = x;
  lastMouseY = y;

  // Jouer le son de clic
  playSound('buttonClick', 0.2);

  // Clic droit pour d√©placer les unit√©s ou collecter des ressources
  if (e.button === 2) {
    // Convertir les coordonn√©es de la souris en coordonn√©es du monde
    const worldX = (x + gameState.camera.x) / config.tileSize;
    const worldY = (y + gameState.camera.y) / config.tileSize;

    // Arrondir les coordonn√©es
    const tileX = Math.floor(worldX);
    const tileY = Math.floor(worldY);

    // V√©rifier si il y a des ressources √† r√©colter
    const resource = getResourceAt(tileX, tileY);
    const building = getBuildingAt(tileX, tileY);

    // Si des villageois sont s√©lectionn√©s et qu'il y a une ressource
    if (resource && gameState.selected.some(unit => unit.type === 'villager')) {
      for (const unit of gameState.selected) {
        if (unit.type === 'villager') {
          unit.task = 'gather';
          unit.taskTarget = {
            x: resource.obj.x,
            y: resource.obj.y,
            type: resource.type,
            resources: resource.obj.resources
          };
          unit.targetX = resource.obj.x;
          unit.targetY = resource.obj.y;

          // Jouer le son appropri√©
          if (resource.type === 'wood') {
            playSound('villagerAcknowledge', 0.4);
          } else if (resource.type === 'stone') {
            playSound('villagerAcknowledge', 0.4);
          } else if (resource.type === 'food') {
            playSound('villagerAcknowledge', 0.4);
          }
        }
      }

      updateStatus(`${gameState.selected.filter(u => u.type === 'villager').length} villageois assign√©s √† la r√©colte de ${resource.type}`);
    }
    // Si des villageois sont s√©lectionn√©s et qu'il y a un b√¢timent en construction
    else if (building && building.isConstructing && gameState.selected.some(unit => unit.type === 'villager')) {
      for (const unit of gameState.selected) {
        if (unit.type === 'villager') {
          unit.task = 'build';
          unit.taskTarget = building;
          unit.targetX = building.x + building.width / 2;
          unit.targetY = building.y + building.height / 2;
        }
      }

      updateStatus(`${gameState.selected.filter(u => u.type === 'villager').length} villageois assign√©s √† la construction`);
      playSound('villagerAcknowledge', 0.4);
    }
    // Sinon, d√©placer les unit√©s s√©lectionn√©es
    else if (gameState.selected.length > 0) {
      // V√©rifier si le clic est sur un ennemi pour attaquer
      let enemyClicked = false;
      for (const enemy of gameState.enemies) {
        const enemyX = Math.floor(enemy.x);
        const enemyY = Math.floor(enemy.y);

        if (tileX === enemyX && tileY === enemyY) {
          // Ordonner aux unit√©s de combat d'attaquer
          for (const unit of gameState.selected) {
            // Les villageois peuvent aussi attaquer mais avec moins d'efficacit√©
            unit.task = 'attack';
            unit.taskTarget = enemy;
            unit.targetX = enemy.x;
            unit.targetY = enemy.y;

            // Son d'acknowledgement selon le type d'unit√©
            if (unit.type === 'villager') {
              playSound('villagerAcknowledge', 0.4);
            } else {
              playSound('soldierAcknowledge', 0.4);
            }
          }

          enemyClicked = true;
          updateStatus(`${gameState.selected.length} unit√©s attaquent l'ennemi`);
          break;
        }
      }

      // Si pas d'ennemi, juste d√©placer
      if (!enemyClicked) {
        // R√©partir les unit√©s autour du point cible pour √©viter qu'elles se superposent
        const numSelected = gameState.selected.length;
        const radius = Math.sqrt(numSelected) * 0.5;
        let index = 0;

        for (const unit of gameState.selected) {
          // Calculer un d√©calage pour chaque unit√©
          const angle = (index / numSelected) * Math.PI * 2;
          const offsetX = Math.cos(angle) * radius;
          const offsetY = Math.sin(angle) * radius;

          unit.targetX = worldX + offsetX;
          unit.targetY = worldY + offsetY;

          // R√©initialiser la t√¢che si l'unit√© en avait une
          unit.task = null;
          unit.taskTarget = null;

          // Son d'acknowledgement selon le type d'unit√©
          if (unit.type === 'villager') {
            if (Math.random() < 0.3) playSound('villagerAcknowledge', 0.3);
          } else {
            if (Math.random() < 0.3) playSound('soldierAcknowledge', 0.3);
          }

          index++;
        }

        updateStatus(`${numSelected} unit√©s en d√©placement`);
      }
    }

    return;
  }

  // Clic gauche
  // Mode construction actif
  if (gameState.buildMode) {
    const worldX = Math.floor((x + gameState.camera.x) / config.tileSize);
    const worldY = Math.floor((y + gameState.camera.y) / config.tileSize);

    if (placeBuildingAt(worldX, worldY,
                       gameState.buildMode.type,
                       gameState.buildMode.width,
                       gameState.buildMode.height,
                       gameState.buildMode.populationProvided)) {
      updateStatus(`Construction de ${getBuildingName(gameState.buildMode.type)} commenc√©e`);

      // Assigner des villageois s√©lectionn√©s √† la construction
      for (const unit of gameState.selected) {
        if (unit.type === 'villager') {
          unit.task = 'build';
          unit.taskTarget = gameState.buildings[gameState.buildings.length - 1];
          unit.targetX = worldX + gameState.buildMode.width / 2;
          unit.targetY = worldY + gameState.buildMode.height / 2;
        }
      }
    } else {
      updateStatus("Impossible de construire √† cet endroit");
      playSound('errorSound', 0.5);
    }

    return;
  }

  // Commencer la s√©lection
  gameState.selectionBox = {
    startX: x,
    startY: y,
    endX: x,
    endY: y
  };
}

function handleMouseMove(e) {
  const x = e.offsetX;
  const y = e.offsetY;
  lastMouseX = x;
  lastMouseY = y;

  // Mettre √† jour la bo√Æte de s√©lection si on est en train de s√©lectionner
  if (gameState.selectionBox) {
    gameState.selectionBox.endX = x;
    gameState.selectionBox.endY = y;
  }

  // D√©placer la cam√©ra si la souris est pr√®s des bords
  const edgeSize = 30;
  const cameraSpeed = 20;

  if (x < edgeSize) {
    gameState.camera.targetX = Math.max(0, gameState.camera.x - cameraSpeed);
  } else if (x > canvas.width - edgeSize) {
    gameState.camera.targetX = Math.min(config.mapWidth * config.tileSize - canvas.width,
                                       gameState.camera.x + cameraSpeed);
  }

  if (y < edgeSize) {
    gameState.camera.targetY = Math.max(0, gameState.camera.y - cameraSpeed);
  } else if (y > canvas.height - edgeSize) {
    gameState.camera.targetY = Math.min(config.mapHeight * config.tileSize - canvas.height,
                                       gameState.camera.y + cameraSpeed);
  }
}

function handleMouseUp(e) {
  // Si on √©tait en train de faire une s√©lection
  if (gameState.selectionBox) {
    // Calculer les limites de la bo√Æte de s√©lection
    const { startX, startY, endX, endY } = gameState.selectionBox;
    const left = Math.min(startX, endX) + gameState.camera.x;
    const right = Math.max(startX, endX) + gameState.camera.x;
    const top = Math.min(startY, endY) + gameState.camera.y;
    const bottom = Math.max(startY, endY) + gameState.camera.y;

    // R√©initialiser la s√©lection
    gameState.selected = [];

    // Si la bo√Æte est tr√®s petite, consid√©rer comme un clic simple
    if (Math.abs(endX - startX) < 5 && Math.abs(endY - startY) < 5) {
      const worldX = Math.floor((startX + gameState.camera.x) / config.tileSize);
      const worldY = Math.floor((startY + gameState.camera.y) / config.tileSize);

      // V√©rifier si une unit√© est cliqu√©e
      const allUnits = [
        ...gameState.units.villagers,
        ...gameState.units.soldiers,
        ...gameState.units.archers,
        ...gameState.units.knights
      ];

      for (const unit of allUnits) {
        const unitX = Math.floor(unit.x);
        const unitY = Math.floor(unit.y);

        if (unitX === worldX && unitY === worldY) {
          unit.selected = true;
          gameState.selected.push(unit);
          break; // S√©lectionner seulement une unit√© en cas de clic simple
        }
      }
    } else {
      // S√©lectionner les unit√©s dans la bo√Æte
      const allUnits = [
        ...gameState.units.villagers,
        ...gameState.units.soldiers,
        ...gameState.units.archers,
        ...gameState.units.knights
      ];

      for (const unit of allUnits) {
        const unitX = unit.x * config.tileSize;
        const unitY = unit.y * config.tileSize;

        // V√©rifier si l'unit√© est dans la bo√Æte de s√©lection
        if (unitX >= left && unitX <= right && unitY >= top && unitY <= bottom) {
          unit.selected = true;
          gameState.selected.push(unit);
        } else {
          unit.selected = false;
        }
      }
    }

    // Afficher le nombre d'unit√©s s√©lectionn√©es
    if (gameState.selected.length > 0) {
      updateStatus(`${gameState.selected.length} unit√©s s√©lectionn√©es`);
      playSound('buttonClick', 0.2);
    } else {
      updateStatus("S√©lectionnez des unit√©s et cliquez pour les d√©placer");
    }

    // R√©initialiser la bo√Æte de s√©lection
    gameState.selectionBox = null;
  }
}

function handleMinimapClick(e) {
  // R√©cup√©rer les coordonn√©es relatives √† la mini-carte
  const rect = minimap.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;

  // Convertir en coordonn√©es du monde
  const worldX = (x / minimap.width) * (config.mapWidth * config.tileSize);
  const worldY = (y / minimap.height) * (config.mapHeight * config.tileSize);

  // Centrer la cam√©ra sur ce point
  gameState.camera.targetX = worldX - canvas.width / 2;
  gameState.camera.targetY = worldY - canvas.height / 2;

  // Limiter les coordonn√©es de la cam√©ra
  gameState.camera.targetX = Math.max(0, Math.min(config.mapWidth * config.tileSize - canvas.width, gameState.camera.targetX));
  gameState.camera.targetY = Math.max(0, Math.min(config.mapHeight * config.tileSize - canvas.height, gameState.camera.targetY));

  // Emp√™cher l'√©v√©nement par d√©faut
  e.preventDefault();

  // Son de clic
  playSound('buttonClick', 0.2);
}

function handleKeyDown(e) {
  // Raccourcis clavier
  switch (e.key) {
    case 'Escape':
      // Annuler la s√©lection ou le mode construction
      if (gameState.buildMode) {
        gameState.buildMode = null;
        updateStatus("Mode construction annul√©");
      } else {
        for (const unit of gameState.selected) {
          unit.selected = false;
        }
        gameState.selected = [];
        updateStatus("S√©lection annul√©e");
      }
      playSound('buttonClick', 0.2);
      break;

    case 'Delete':
      // Supprimer les unit√©s s√©lectionn√©es
      for (const unit of gameState.selected) {
        let unitArray;
        switch (unit.type) {
          case 'villager': unitArray = gameState.units.villagers; break;
          case 'soldier': unitArray = gameState.units.soldiers; break;
          case 'archer': unitArray = gameState.units.archers; break;
          case 'knight': unitArray = gameState.units.knights; break;
        }

        const index = unitArray.indexOf(unit);
        if (index !== -1) {
          unitArray.splice(index, 1);
          gameState.resources.population--;
        }
      }
      gameState.selected = [];
      updateStatus("Unit√©s supprim√©es");
      updateUI();
      break;

    case 'a':
      // S√©lectionner toutes les unit√©s (avec Ctrl+A)
      if (e.ctrlKey) {
        gameState.selected = [];
        const allUnits = [
          ...gameState.units.villagers,
          ...gameState.units.soldiers,
          ...gameState.units.archers,
          ...gameState.units.knights
        ];

        for (const unit of allUnits) {
          unit.selected = true;
          gameState.selected.push(unit);
        }

        updateStatus(`${gameState.selected.length} unit√©s s√©lectionn√©es`);
        playSound('buttonClick', 0.2);
        e.preventDefault();
      }
      break;

    // Touches de d√©placement de la cam√©ra (ZQSD ou WASD)
    case 'z':
    case 'w':
    case 'ArrowUp':
      gameState.camera.targetY = Math.max(0, gameState.camera.targetY - 20);
      break;

    case 's':
    case 'ArrowDown':
      gameState.camera.targetY = Math.min(config.mapHeight * config.tileSize - canvas.height,
                                         gameState.camera.targetY + 20);
      break;

    case 'q':
    case 'a':
    case 'ArrowLeft':
      if (!e.ctrlKey) {
        gameState.camera.targetX = Math.max(0, gameState.camera.targetX - 20);
      }
      break;

    case 'd':
    case 'ArrowRight':
      gameState.camera.targetX = Math.min(config.mapWidth * config.tileSize - canvas.width,
                                         gameState.camera.targetX + 20);
      break;

    // Touches num√©riques pour s√©lectionner des groupes d'unit√©s
    case '1': case '2': case '3': case '4': case '5':
      const groupNum = parseInt(e.key);
      if (e.ctrlKey) {
        // Ctrl+Num pour d√©finir un groupe
        createUnitGroup(groupNum);
      } else {
        // Num pour s√©lectionner un groupe
        selectUnitGroup(groupNum);
      }
      break;
  }
}

// Infobulles
function showTooltip(e) {
  const btn = e.target;

  // R√©cup√©rer le type d'√©l√©ment
  let title, description;
  if (btn.id.includes('villager')) {
    title = "Villageois";
    description = "R√©colte des ressources et construit des b√¢timents. Co√ªt: 5 üåæ";
  } else if (btn.id.includes('soldier')) {
    title = "Soldat";
    description = "Unit√© de combat de base. Co√ªt: 10 üåæ, 5 ü™µ";
  } else if (btn.id.includes('archer')) {
    title = "Archer";
    description = "Attaque √† distance. Co√ªt: 10 üåæ, 10 ü™µ";
  } else if (btn.id.includes('knight')) {
    title = "Chevalier";
    description = "Unit√© de combat puissante. Co√ªt: 20 üåæ, 15 ‚õèÔ∏è";
  } else if (btn.id.includes('house')) {
    title = "Maison";
    description = "Augmente la population maximale de 5. Co√ªt: 10 ü™µ";
  } else if (btn.id.includes('farm')) {
    title = "Ferme";
    description = "Produit de la nourriture automatiquement. Co√ªt: 5 ü™µ, 3 ‚õèÔ∏è";
  } else if (btn.id.includes('lumbermill')) {
    title = "Scierie";
    description = "Produit du bois automatiquement. Co√ªt: 8 ü™µ, 5 ‚õèÔ∏è";
  } else if (btn.id.includes('quarry')) {
    title = "Carri√®re";
    description = "Produit de la pierre automatiquement. Co√ªt: 10 ü™µ, 5 ‚õèÔ∏è";
  } else if (btn.id.includes('barracks')) {
    title = "Caserne";
    description = "Permet de cr√©er des soldats et des chevaliers. Co√ªt: 15 ü™µ, 10 ‚õèÔ∏è";
  } else if (btn.id.includes('archery')) {
    title = "Stand de tir";
    description = "Permet de cr√©er des archers. Co√ªt: 15 ü™µ, 8 ‚õèÔ∏è";
  }

  tooltip.querySelector('.tooltip-title').textContent = title;
  tooltip.querySelector('.tooltip-description').textContent = description;

  const rect = btn.getBoundingClientRect();
  tooltip.style.left = `${rect.right + 10}px`;
  tooltip.style.top = `${rect.top}px`;
  tooltip.style.opacity = '1';
}

function hideTooltip() {
  tooltip.style.opacity = '0';
}

// Groupes d'unit√©s
const unitGroups = [{}, {}, {}, {}, {}, {}]; // 1-5

function createUnitGroup(groupNum) {
  if (gameState.selected.length === 0) return;

  // Enregistrer les unit√©s s√©lectionn√©es dans le groupe
  unitGroups[groupNum] = {
    units: [...gameState.selected]
  };

  updateStatus(`Groupe ${groupNum} cr√©√© avec ${gameState.selected.length} unit√©s`);
  playSound('buttonClick', 0.2);
}

function selectUnitGroup(groupNum) {
  const group = unitGroups[groupNum];
  if (!group.units || group.units.length === 0) return;

  // D√©s√©lectionner toutes les unit√©s
  for (const unit of gameState.selected) {
    unit.selected = false;
  }

  // R√©initialiser la s√©lection
  gameState.selected = [];

  // S√©lectionner les unit√©s du groupe qui existent encore
  for (const savedUnit of group.units) {
    let found = false;

    // Chercher dans tous les types d'unit√©s
    const allUnitTypes = [
      { array: gameState.units.villagers, type: 'villager' },
      { array: gameState.units.soldiers, type: 'soldier' },
      { array: gameState.units.archers, type: 'archer' },
      { array: gameState.units.knights, type: 'knight' }
    ];

    for (const { array } of allUnitTypes) {
      const unit = array.find(u => u === savedUnit);
      if (unit) {
        unit.selected = true;
        gameState.selected.push(unit);
        found = true;
        break;
      }
    }
  }

  updateStatus(`Groupe ${groupNum} s√©lectionn√© (${gameState.selected.length} unit√©s)`);
  playSound('buttonClick', 0.2);
}

// Initialisation du jeu
function initGame() {
  resizeCanvas();
  initMap();
  updateUI();

  // Cr√©er un h√¥tel de ville au d√©part
  placeBuildingAt(
    Math.floor(config.mapWidth / 2) - 2,
    Math.floor(config.mapHeight / 2) - 2,
    'towncenter', 4, 3, 10
  );

  // Cr√©er des villageois de d√©part
  spawnUnit(Math.floor(config.mapWidth / 2), Math.floor(config.mapHeight / 2), 'villager');
  spawnUnit(Math.floor(config.mapWidth / 2) + 1, Math.floor(config.mapHeight / 2), 'villager');
  spawnUnit(Math.floor(config.mapWidth / 2), Math.floor(config.mapHeight / 2) + 1, 'villager');

  // R√©v√©ler la zone de d√©part
  revealArea(Math.floor(config.mapWidth / 2), Math.floor(config.mapHeight / 2), 10);

  // D√©marrer la musique de fond
  if (config.musicEnabled) {
    playMusic('gameTheme', 0.2);
  }

  // D√©marrer les intervalles r√©guliers
  setInterval(spawnEnemy, config.enemySpawnInterval);

  // D√©marrer la boucle de jeu
  window.requestAnimationFrame(gameLoop);

  updateStatus("Bienvenue dans Strategic Kingdoms 2025! Construisez votre royaume et d√©fendez-le contre les ennemis.");
}

// Commencer le chargement des ressources
loadResources();

</script>
</body>
</html>
